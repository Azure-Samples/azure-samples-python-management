# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.identity import DefaultAzureCredential

from azure.mgmt.quota import QuotaMgmtClient

import re
import time

"""
# PREREQUISITES
    pip install azure-identity
    pip install azure-mgmt-quota==2.0.0b1
# USAGE
    Before run the sample, please set the values of the client ID, tenant ID and client secret
    of the AAD application as environment variables: AZURE_CLIENT_ID, AZURE_TENANT_ID,
    AZURE_CLIENT_SECRET. For more info about how to get the value, please see:
    https://docs.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal
"""

def cut_id(string):
    # regex finds the portion after the last slash and before the question
    match = re.search(r'/([^/?]+)\?', string)
    return match.group(1)

def cut_url(string):
    # regex removes everything after and including the first '&' symbol
    return re.sub(r'&.*', '', string)

def requestGroup(client, id, management_group_id, group_quota_name):
    return client.group_quota_limits_request.get(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
        request_id_parameter=id,
    )

def requestSubscription(client, id, management_group_id, group_quota_name):
    return client.group_quota_subscription_allocation_request.get(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
        allocation_id=id,
    )

def createGroupQuota(client, group_quota_name, management_group_id):
    data = {
      "properties": {
        "displayName": "put_group_quotas_pythonSDK",
        "additionalAttributes": {
          "groupId": {
            "groupingIdType": "BillingId",
            "value": "0000000"
          },
        }
      }
    }

    response = client.group_quotas.begin_create_or_update(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
        group_quota_put_request_body=data,
    ).result()
    print(response)

def getGroupQuota(client, group_quota_name, management_group_id):    
    response = client.group_quotas.get(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
    )
    print(response)

def addSubscription(client, group_quota, management_group_id):
    response = client.group_quota_subscriptions.begin_create_or_update(
        management_group_id=management_group_id,
        group_quota_name=group_quota,
    ).result()
    print(response)

def deleteSubscription(client, group_quota, management_group_id):
    response = client.group_quota_subscriptions.begin_delete(
        management_group_id=management_group_id,
        group_quota_name=group_quota,
    ).result()
    print(response)

def createGroupQuotaLimitRequest(client, group_quota_name, management_group_id, resource_name, data):
    response = client.group_quota_limits_request.begin_create_or_update(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
        resource_provider_name="Microsoft.Quota",
        resource_name=resource_name,
        group_quota_request = data,
    )
    
    filtered_properties = response._polling_method._initial_response.http_response.headers._store['location']
    id = cut_id(filtered_properties[1])
    url = cut_url(filtered_properties[1])
    
    response = requestGroup(client, id, management_group_id, group_quota_name)

    timeoutLimit = 240
    timeoutSleep = 15
    while timeoutLimit > 0 and response.properties.provisioning_state in ('Accepted', 'InProgress'):
      print('Polling status: ' + response.properties.provisioning_state)
      time.sleep(timeoutSleep)
      timeoutLimit -= timeoutSleep
      response = requestGroup(client,id, management_group_id, group_quota_name)

    if timeoutLimit == 0:
        print('The operation is still running, the Polling time limit was reached')

    print('Polling completed, final status: ' + response.properties.provisioning_state)

    if response.properties.provisioning_state == 'Escalated':
        print("Please contact your Capacity Manager")
    
    if response.properties.provisioning_state != 'Succeeded':
        print('Status url: ' + url)


def createSubscriptionAllocationRequest(client, group_quota_name, management_group_id, resource_name, data):
    response = client.group_quota_subscription_allocation_request.begin_create_or_update(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
        resource_provider_name="Microsoft.Compute",
        resource_name=resource_name,
        allocate_quota_request = data,
    )
    
    filtered_properties = response._polling_method._initial_response.http_response.headers._store['location']
    id = cut_id(filtered_properties[1])
    url = cut_url(filtered_properties[1])
    
    response = requestSubscription(client,id, management_group_id, group_quota_name)

    timeoutLimit = 240
    timeoutSleep = 15
    while timeoutLimit > 0 and response.properties.provisioning_state in ('Accepted', 'InProgress'):
      print('Polling status: ' + response.properties.provisioning_state)
      time.sleep(timeoutSleep)
      timeoutLimit -= timeoutSleep
      response = requestSubscription(client,id, management_group_id, group_quota_name)

    if timeoutLimit == 0:
        print('The operation is still running, the Polling time limit was reached')

    print('Polling completed, final status: ' + response.properties.provisioning_state)

    if response.properties.provisioning_state == 'Escalated':
        print("Please contact your Capacity Manager")
    
    if response.properties.provisioning_state != 'Succeeded':
        print('Status url: ' + url)

def deleteGroupQuota(client, group_quota_name, management_group_id):
    response = client.group_quotas.begin_delete(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
    ).result()
    print(response)

def getGroupQuotaLimit(client, group_quota_name, management_group_id):
    response = client.group_quotas.get(
        management_group_id=management_group_id,
        group_quota_name=group_quota_name,
    )
    print(response)

def main():
    client = QuotaMgmtClient(
        credential=DefaultAzureCredential(),
        subscription_id="00000000-0000-0000-0000-000000000000",
    )
    
    management_group_id="[ManagmentGroup]"
    group_quota_name="[GroupQuotaName]"
    resource_name="[ResourceName]"
    limit=20
    location="westus"

    data = {
      "properties": {
        "requestedResource": {
          "properties": {
            "limit": limit,
            "region": location
          }
        }
      }
    }

    #Group Quota Functions
    createGroupQuota(client, group_quota_name, management_group_id)
    getGroupQuota(client, group_quota_name, management_group_id)

    #Subscription Functions
    addSubscription(client, group_quota_name, management_group_id)
    deleteSubscription(client, group_quota_name, management_group_id)

    #GroupQuotaLimit
    createGroupQuotaLimitRequest(client, group_quota_name, management_group_id, resource_name, data)
    getGroupQuotaLimit(client, group_quota_name, management_group_id)

    #SubscriptionQuotaAllocation
    createSubscriptionAllocationRequest(client, group_quota_name, management_group_id, resource_name, data)
    
    #Cleanup
    deleteSubscription(client, group_quota_name, management_group_id)
    deleteGroupQuota(client, group_quota_name, management_group_id)

if __name__ == "__main__":
    main()
